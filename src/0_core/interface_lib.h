#ifndef _INTERFACE_LIB_H_
#define _INTERFACE_LIB_H_

#include <algorithm>  // tolower
#include <cassert>
#include <iomanip>
#include <iostream>
#include <ostream>
#include <string>
#include <systemc>
#include <vector>

namespace cactus {

/*************** Device operation format definition ********************/
class Microwave_channel {
  public:
    unsigned int              global_unique_id;
    std::vector<unsigned int> target_qubits;
    std::string               operation;
};

// The microwave event, which contains multiple channel(for cc-light, there are two channels),
// each channel has its targeting qubits and the quantum operation
class Microwave_device {
  public:
    std::vector<Microwave_channel> channels;
};

class Measurement_feedline {
  public:
    int*  target_qubits;
    bool* valid;
};

// The measurement event which contains the feedline
class Msmt_event {
  public:
    Measurement_feedline feedline;
    unsigned int         num_of_qubits;
};

// -----------------------------------------------------------------------------------------------
// Physical operation generated by analog devices in the ADI
// -----------------------------------------------------------------------------------------------
class Physical_operation {
  public:
    bool        is_msmt;    // if it is a measurement operation
    std::string operation;  // the name of this operation
    int         cycle;      // the cycle in which this operatiobn starts

    Physical_operation() {
        this->is_msmt   = false;
        this->operation = "Null";
        this->cycle     = 0;
    }

    inline bool operator==(const Physical_operation& other) {
        return ((this->is_msmt == other.is_msmt) && (this->operation == other.operation) &&
                (this->cycle == other.cycle));
    }
};

inline std::string to_string(const Physical_operation& e) {
    std::string _str_;
    if (e.is_msmt) {
        _str_ = "Phy_op: (Msmt, cycle: " + std::to_string(e.cycle) + ")";
    } else {
        _str_ = "Phy_op (" + e.operation + ", cycle: " + std::to_string(e.cycle) + ")";
    }
    return _str_;
}

// the operator << should be defined because it is required when used with sc_vector
inline std::ostream& operator<<(std::ostream& os, const Physical_operation& e) {
    return os << to_string(e);
};

inline void sc_trace(sc_core::sc_trace_file* tf, const Physical_operation& e,
                     const std::string& name) {
    sc_trace(tf, e.cycle, name + ".clock cycle");
};

// class Quantum_operation {
//   public:
//     std::string  operation;
//     unsigned int cycle;
//     unsigned int pair_index;
//     bool         pair_valid;
//     inline bool  operator==(const Quantum_operation& other) {
//         return ((this->operation == other.operation) && (this->cycle == other.cycle));
//     }
// };

// This is an atom quantum operation, which means:
//   It does not support Single-Operation-Multiple-Qubit execution.
//   <target_qubits> only contains the target qubits of the <operation>.
//   It target_qubits has three elements, then <operation> is a three-qubit gate.
// One operation applied on multiple qubits should be represented using multiple Atom_qop instances.
class Atom_qop {
  public:
    std::string               operation;
    std::vector<unsigned int> target_qubits;

    bool is_qnop() { return (operation.length() == 0 || operation.compare("Null") == 0); }

  public:
    Atom_qop() {
        operation = "";
        target_qubits.clear();
    }
};

inline bool operator==(const Atom_qop& qop1, const Atom_qop& qop2) {
    return ((qop1.operation == qop2.operation) && (qop1.target_qubits == qop2.target_qubits));
}

inline std::string to_string(const Atom_qop& qop) {

    std::string _str_ = qop.operation + "(";

    for (size_t i = 0; i < qop.target_qubits.size(); i++) {

        _str_ = _str_ + std::to_string(qop.target_qubits[i]) + ", ";
    }

    if (_str_.back() == ' ') {

        _str_ = _str_.substr(0, _str_.length() - 2);
    }

    _str_ += ") ";

    return _str_;
}

inline std::ostream& operator<<(std::ostream& os, const Atom_qop& qop) {
    return os << to_string(qop);
};

inline void sc_trace(sc_core::sc_trace_file* tf, const Atom_qop& qop, const std::string& name){};

class Ops_2_qsim {
  public:  // accessible methods
    void trim_qnops() {

        auto it = atom_ops.begin();

        while (it != atom_ops.end()) {
            if (it->is_qnop()) {
                it = atom_ops.erase(it);
            } else {
                ++it;
            }
        }
    };

    void reset() {
        cycle     = 0;
        triggered = false;
        atom_ops.clear();
    }

  public:  // constructor
    Ops_2_qsim() { reset(); }

  public:  // data
    unsigned int          cycle;
    bool                  triggered;
    std::vector<Atom_qop> atom_ops;
};

inline bool operator==(const Ops_2_qsim& moment1, const Ops_2_qsim& moment2) {
    return (moment1.cycle == moment2.cycle && moment1.atom_ops == moment2.atom_ops);
}

inline std::string to_string(const Ops_2_qsim& moment) {
    if (!moment.triggered) {
        return std::string("");
    }

    std::string _str_ = "If_qsim (cycle: " + std::to_string(moment.cycle) + " ";
    for (size_t i = 0; i < moment.atom_ops.size(); i++) {
        _str_ = _str_ + to_string(moment.atom_ops[i]) + " ";
    }
    _str_ += ")";
    return _str_;
}

inline std::ostream& operator<<(std::ostream& os, const Ops_2_qsim& moment) {
    return os << to_string(moment);
};

inline void sc_trace(sc_core::sc_trace_file* tf, const Ops_2_qsim& moment,
                     const std::string& name){};

class Res_from_qsim {
  public:
    unsigned int cycle;
    // only valid measurement reuslts will be put in this vector.
    // each result has this structure: <qubit_number, result_for_this_qubit>
    std::vector<std::pair<unsigned int, unsigned int>> results;

  public:
    Res_from_qsim() { reset(); }

    void reset() {
        cycle = 0;
        results.clear();
    }
};

inline bool operator==(const Res_from_qsim& res1, const Res_from_qsim& res2) {
    return (res1.cycle == res2.cycle && res1.results == res2.results);
}

inline std::string to_string(const Res_from_qsim& e) { return std::string(""); }

inline std::ostream& operator<<(std::ostream& os, const Res_from_qsim& res_from_qsim) {
    return os << to_string(res_from_qsim);
};

inline void sc_trace(sc_core::sc_trace_file* tf, const Res_from_qsim& res_from_qsim,
                     const std::string& name){};

}  // namespace cactus

#endif
